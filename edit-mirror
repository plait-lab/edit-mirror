#!/usr/bin/env node

////////////////////////////////////////////////////////////////////////////////
// Imports

const util = require("util");
const path = require("path");
const fs = require("fs");
const fsp = require("fs/promises");
const http = require("http"); // TODO: upgrade to https

const chokidar = require("chokidar");
const FormData = require("form-data");
const tar = require("tar");

const read = util.promisify(fs.read);

////////////////////////////////////////////////////////////////////////////////
// Constants

const VERSION = "0.1.0";

const SERVER_HOSTNAME = "localhost:8080";
const UPLOAD_PATH = "upload";

const UPLOAD_REQUEST_THRESHOLD_HOURS = 0.01;

const PLUGIN_DIR = "___edit-mirror___";

const LOGS_DIR = PLUGIN_DIR + "/logs";
const CURRENT_LOGS_DIR = LOGS_DIR + "/current";
const CURRENT_FILE_LOG_DIR = CURRENT_LOGS_DIR + "/files";
const PENDING_UPLOAD_DIR = LOGS_DIR + "/pending-upload";

const ID_PATH = PLUGIN_DIR + "/id.txt";
const LAST_UPLOAD_REQUEST_PATH = PLUGIN_DIR + "/last-upload-request.txt";
const DEMOGRAPHICS_PATH = PLUGIN_DIR + "/demographics.txt";

const WATCHED_EXTENSION = ".elm";
const WATCHED_FILES = ["**/*.elm", "elm.json"];
const IGNORED_PATHS = [PLUGIN_DIR + "/**", "elm-stuff/**"];

const FILE_URI_PREFIX = "file://";

////////////////////////////////////////////////////////////////////////////////
// Pseudo-constants (set once in init)

let ROOT_PATH = null;
let ID = null;

////////////////////////////////////////////////////////////////////////////////
// Helpers

// File helpers

// Source: https://stackoverflow.com/a/22185855
function copyRecursiveSync(src, dest) {
  const exists = fs.existsSync(src);
  const stats = exists && fs.statSync(src);
  const isDirectory = exists && stats.isDirectory();
  if (isDirectory) {
    fs.mkdirSync(dest);
    fs.readdirSync(src).forEach(function(childItemName) {
      copyRecursiveSync(
				path.join(src, childItemName),
        path.join(dest, childItemName)
			);
    });
  } else {
    fs.copyFileSync(src, dest);
  }
}

// Time helpers

function millisToHours(millis) {
  return millis / 3_600_000;
}

// IO helpers

async function get(n) {
  const { buffer } = await read(0, Buffer.alloc(n), 0, n, null);
  return buffer.toString("utf8");
}

async function getLine() {
  let line = "";
  while (true) {
    const c = await get(1);
    if (c === "\n") {
      break;
    }
    line += c;
  }
  return line.trim();
}

const logStream = fs.createWriteStream(
  "/Users/jlubin/Desktop/log.txt", { flags: "a"}
);

function log(text) {
  const timestamp = new Date().getTime();
  logStream.write("[" + timestamp + "] " + text + "\n");
}

function dlog(text) {
  log("[DEBUG] " + text);
}

// JSON RPC helpers

function sendMessage(content) {
  process.stdout.write(
    "Content-Length: " + content.length + "\r\n\r\n" + content
  );
}

function sendResponse(id, result) {
  sendMessage(JSON.stringify({
    id: id,
    result: result,
    jsonrpc: "2.0"
  }));
}

let globalIdCounter = 1;
function sendRequest(method, params) {
  const id = globalIdCounter;
  sendMessage(JSON.stringify({
    id: id,
    method: method,
    params: params,
    jsonrpc: "2.0"
  }));
  globalIdCounter += 1;
  return id;
}

function sendPromptRequest(message, options) {
  return sendRequest("window/showMessageRequest", {
    type: 3, // Info
    message: message,
    actions: options.map(opt => ({ title: opt }))
  });
}

////////////////////////////////////////////////////////////////////////////////
// User consent

let consentToUploadId = null;

function requestUpload() {
  consentToUploadId = sendPromptRequest(
    "Do you consent to uploading all edit history since your last upload?",
    ["Yes", "No"]
  );
}

function indicatesConsent(option) {
  return option === "Yes";
}

async function requestUploadIfNecessary(currentTimestamp) {
  const lastRequested = parseInt(await fsp.readFile(LAST_UPLOAD_REQUEST_PATH));
  const hoursElapsed = millisToHours(currentTimestamp - lastRequested);
  dlog("Hours elapsed: " + hoursElapsed);
  if (hoursElapsed > UPLOAD_REQUEST_THRESHOLD_HOURS) {
    log("Requesting upload after " + hoursElapsed.toFixed(2) + " hours");
    await fsp.writeFile(LAST_UPLOAD_REQUEST_PATH, currentTimestamp.toString());
    requestUploadConsent();
  }
}

////////////////////////////////////////////////////////////////////////////////
// Storage manager

async function store(timestamp, kind, sourcePath, sourceContent) {
  const dir = CURRENT_FILE_LOG_DIR + "/" + sourcePath;
  const filename = dir + "/" + timestamp + "-" + kind;

  await fsp.mkdir(dir, { recursive: true });
  await fsp.writeFile(filename, sourceContent);
}

////////////////////////////////////////////////////////////////////////////////
// File watcher

function watchHandler(kind) {
  return (async path => {
    // Handles https://github.com/paulmillr/chokidar/issues/544
    if (!path.endsWith(WATCHED_EXTENSION)) {
      return;
    }
    const timestamp = new Date().getTime();
    const content = kind === "unlink" ? "" : await fsp.readFile(path);
    store(timestamp, "watched-" + kind, path, content);
  });
}

function watchFiles() {
  chokidar.watch(WATCHED_FILES, { ignored: IGNORED_PATHS })
    .on("add", watchHandler("add"))
    .on("change", watchHandler("change"))
    .on("unlink", watchHandler("unlink"));
}

////////////////////////////////////////////////////////////////////////////////
// Uploader

function upload() {
  const timestamp = new Date().getTime();
  const pendingUpload = PENDING_UPLOAD_DIR + "/" + timestamp;

  fs.renameSync(CURRENT_LOGS_DIR, pendingUpload);
  fs.mkdirSync(CURRENT_LOGS_DIR, { recursive: true });

  fs.copyFileSync(ID_PATH,
    pendingUpload + "/id.txt");
  fs.copyFileSync(DEMOGRAPHICS_PATH,
    pendingUpload + "/demographics.txt");

  const form = new FormData();

  form.append("client_version", VERSION);
  form.append("client_id", ID);

  const zippedStream =
    tar.create(
      { gzip: true
      },
      [ pendingUpload ]
    );
  form.append("data_tarball", zippedStream);

  const req = http.request({
    method: "POST",
    host: SERVER_HOSTNAME,
    path: UPLOAD_PATH,
    headers: form.getHeaders()
  }, res => {
    switch (res.statusCode) {
      case 200: // OK
        fs.rmSync(pendingUpload, { recursive: true, force: true });
        res.resume();
        break;

      default: // Error
        res.setEncoding("utf8");
        let rawData = "";
        res.on("data", chunk => { rawData += chunk; });
        res.on("end", () => {
          log(
            "Server responded with status code "
              + res.statusCode
              + ": "
              + rawData
          );
        });
        break;
    }
  });

  form.pipe(req);
}

////////////////////////////////////////////////////////////////////////////////
// Language server protocol

async function listen(handler) {
  log("Listening...");
  while (true) {
    const header = {};
    while (true) {
      const line = await getLine();
      if (line.length === 0) {
        break;
      }
      const [key, val] = line.split(": ");
      header[key] = val;
    }

    const contentLength = parseInt(header["Content-Length"]);
    const content = await get(contentLength);

    // Body
    await handle(JSON.parse(content));
  }
}

async function handle(msg) {
  const timestamp = new Date().getTime();

  switch (msg.method) {
    case "initialize":
      log("Starting initialization...");

      const rootUri = msg.params.rootUri;
      if (!rootUri.startsWith(FILE_URI_PREFIX)) {
        throw new Error("Non-file URIs not supported: '" + rootUri + "'");
      }
      ROOT_PATH = rootUri.substring(FILE_URI_PREFIX.length);

      ID = await fsp.readFile(ID_PATH);

			watchFiles();

			sendResponse(msg.id, {
        capabilities: {
          textDocumentSync: 1
        }
      });

      log("Initialized!");

      break;

    case "textDocument/didChange":
      const uri = msg.params.textDocument.uri;
      if (!uri.startsWith(FILE_URI_PREFIX)) {
        log("Non-file URIs not supported: '" + uri + "'");
        return;
      }

      const path = uri.substring(FILE_URI_PREFIX.length);
      if (!path.startsWith(ROOT_PATH)) {
        throw new Error(
          "Text document path '"
            + path
            + "' does not begin with root path '"
            + ROOT_PATH
            + "'"
        );
      }

      const contentChanges = msg.params.contentChanges;
      const lastContentChange = contentChanges[contentChanges.length - 1];
      if ("range" in lastContentChange) {
        throw new Error(
          "Last content change is non-incremental: "
            + JSON.stringify(lastContentChange)
        );
      }

      const sourceFilename = path.substring(ROOT_PATH.length + 1);
      const sourceContent = lastContentChange.text;

      await store(timestamp, "buffer", sourceFilename, sourceContent);
      await requestUploadIfNecessary(timestamp);

      break;

    case "textDocument/didOpen": // No new info
    case "textDocument/didClose": // No new info
    case "textDocument/didSave": // Handled by file system watcher
      break;

    case "window/showMessageRequest":
      dlog("Reached response of showMessageRequest!");
      if (
        consentToUploadId !== null
          && msg.id === consentToUploadId
          && msg.params.result
          && indicatesConsent(msg.params.result.title)
      ) {
        upload();
      }
      break;

    case "shutdown":
      dlog("shutdown");
      sendResponse(msg.id, null);
      break;

    case "exit":
      dlog("exit");
      process.exit(0);
      break;

    default:
      break;
  }
}

////////////////////////////////////////////////////////////////////////////////
// Uploader

// NOTE: the "server" can just be a static page on github pages
// ... although it's actually probably fine to just use DigitalOcean
async function tryUpdate() {
  // TODO
  // make http request to berkeley server for latest version string
  // if it's different than VERSION, make another request for the latest file
  // download that file, replace current file with it
  //   -> the program will be updated for the next run
  //   also notify user
}

////////////////////////////////////////////////////////////////////////////////
// Main

process.on('uncaughtException', function (error) {
  log("[ERROR] " + error.stack.toString());
});

async function main() {
  log("--- Starting new edit-mirror session ---");
  await tryUpdate();
  await listen(handle);
}

main();
