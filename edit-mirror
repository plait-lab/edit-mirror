#!/usr/bin/env node

// Constants

const LOG_DIR = "__edit-mirror-log__"
const FILE_URI_PREFIX = "file://";

// Imports

const utils = require(utils);
const path = require("path");
const fs = require("fs");
const fsp = require("fs/promises");
const chokidar = require("chokidar");

const read = utils.promisify(fs.read);

// Storage manager

// TODO we might want to buffer this?
async function store(timestamp, kind, sourcePath, sourceContent) {
  const dirs = LOG_DIR + "/file_log/" + sourcePath;
  const filename = dirs + "/" + timestamp + "-" + kind;

  await fsp.mkdir(dirs, { recursive: true });
  await fsp.writeFile(filename, sourceContent);
}

// File watcher

function watchHandler(kind) {
  return (async path => {
    // Handles https://github.com/paulmillr/chokidar/issues/544
    if (!path.endsWith(".elm")) {
      return;
    }
    const content = kind === "unlink" ? "" : await fsp.readFile(path);
    store(new Date().getTime(), "watched-" + kind, path.slice(3), content);
  });
}

function watchFiles() {
  chokidar.watch(["**/*.elm", "elm.json"], { ignored: LOG_DIR + "/**" })
    .on("add", watchHandler("add"))
    .on("change", watchHandler("change"))
    .on("unlink", watchHandler("unlink"));
}

// IO helpers

async function get(n) {
  const buffer = await read(0, Buffer.alloc(1), 0, 1, null);
  return buffer.toString("utf8");
}

async function getLine() {
  let line = "";
  while (true) {
    const c = await get(1);
    if (c === "\n") {
      break;
    }
    line += c;
  }
  return line;
}

function log(text) {
  fs.appendFileSync("/Users/jlubin/Desktop/log.txt", text);
}

// Message helpers

function sendMessage(content) {
  console.log("Content-Length: " + content.length + "\r\n\r\n" + content);
}

function sendResponse(id, result) {
  sendMessage(JSON.stringify({
    id: id,
    result: result,
    jsonrpc: "2.0"
  }));
}

// Listener

async function listen(handler) {
  while (true) {
    await fsRead(0, Buffer.alloc(1), 0, 1, null);

    // Header (TODO assumes only Content-Length is present)
    while (await get(1) != " ");
    const contentLength = parseInt(await getLine());

    // \r\n separates header from body
    await get(2);

    // Body
    handle(JSON.parse(await get(contentLength)));
  }
}

// Handler

let ROOT_PATH = null;

function handle(msg) {
  const timestamp = new Date().getTime();

  switch (msg.method) {
    case "initialize":
      const rootUri = msg.params.rootUri;
      if (!rootUri.startsWith(FILE_URI_PREFIX)) {
        throw new Error("Non-file URIs not supported: '" + rootUri + "'");
        return;
      }
      ROOT_PATH = rootUri.substring(FILE_URI_PREFIX.length);

      // TODO check for startup file in rootPath to see if we should enable
      // plugin

      watchFiles();

      sendResponse(
        msg.id,
        { capabilities: { textDocumentSync: 1 } }
      );

      break;

    case "didChange":
      const uri = msg.params.textDocument.uri;
      if (!uri.startsWith(FILE_URI_PREFIX)) {
        throw new Error("Non-file URIs not supported: '" + uri + "'");
        return;
      }

      const path = uri.substring(FILE_URI_PREFIX.length);
      if (!path.startsWith(ROOT_PATH)) {
        throw new Error(
          "Text document path '"
            + path
            + "' does not begin with root path '"
            + ROOT_PATH
            + "'"
        );
      }

      const contentChanges = msg.params.contentChanges;
      const lastContentChange = contentChanges[contentChanges.length - 1];
      if ("range" in lastContentChange) {
        throw new Error(
          "Last content change is non-incremental: "
            + JSON.stringify(lastContentChange)
        );
      }

      const sourceFilename = path.substring(ROOT_PATH.length + 1);
      const sourceContent = lastContentChange.text;

      await store(timestamp, "buffer", sourceFilename, sourceContent);

      break;

    case "didOpen": // No new info
    case "didClose": // No new info
    case "didSave": // Handled by file system watcher
      break;

    default:
      break;
  }
}

// Main

listen(handle);
